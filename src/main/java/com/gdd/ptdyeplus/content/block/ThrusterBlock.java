package com.gdd.ptdyeplus.content.block;

import net.minecraft.Util;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.core.particles.ParticleOptions;
import net.minecraft.core.particles.ParticleTypes;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.util.RandomSource;
import net.minecraft.world.item.context.BlockPlaceContext;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.HorizontalDirectionalBlock;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.DirectionProperty;
import net.minecraft.world.phys.Vec3;
import net.minecraft.world.phys.shapes.BooleanOp;
import net.minecraft.world.phys.shapes.CollisionContext;
import net.minecraft.world.phys.shapes.Shapes;
import net.minecraft.world.phys.shapes.VoxelShape;

import java.util.EnumMap;
import java.util.Map;

public class ThrusterBlock extends HorizontalDirectionalBlock {
    public static final DirectionProperty FACING = BlockStateProperties.HORIZONTAL_FACING;

    private static final Map<Direction, VoxelShape> SHAPES = Util.make(new EnumMap<>(Direction.class), map -> {
        VoxelShape base = makeBaseShape();
        map.put(Direction.NORTH, base);
        map.put(Direction.SOUTH, rotationShape(Direction.SOUTH, base));
        map.put(Direction.EAST, rotationShape(Direction.EAST, base));
        map.put(Direction.WEST, rotationShape(Direction.WEST, base));
    });

    public ThrusterBlock(Properties properties) {
        super(properties);
        this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH));
    }

    public static void spawnThrusterParticles(Level level, Vec3 nozzlePoint, Vec3 exhaustDirection, Vec3 inheritedMotion, RandomSource random) {
        spawnSingleParticle(level, ParticleTypes.ELECTRIC_SPARK, random, 0.1f, nozzlePoint,
            exhaustDirection.scale(1.0d).add(inheritedMotion));

        spawnSingleParticle(level, ParticleTypes.ELECTRIC_SPARK, random, 0.2f, nozzlePoint,
            exhaustDirection.scale(1.2d).add(inheritedMotion));

        if (random.nextInt(3) == 0) // 1 in 3
            spawnSingleParticle(level, ParticleTypes.ELECTRIC_SPARK, random, 0.2f, nozzlePoint,
                exhaustDirection.scale(1.75d).add(inheritedMotion));

        if (random.nextInt(2) == 0) // 1 in 2
            spawnSingleParticle(level, ParticleTypes.SOUL_FIRE_FLAME, random, 0.2f, nozzlePoint,
                exhaustDirection.scale(0.5d).add(inheritedMotion));

        if (random.nextInt(3) == 0) // 1 in 3
            spawnSingleParticle(level, ParticleTypes.SOUL_FIRE_FLAME, random, 0.3f, nozzlePoint,
                exhaustDirection.scale(0.5d).add(inheritedMotion));

        if (random.nextInt(5) == 0) // 1 in 5
            spawnSingleParticle(level, ParticleTypes.END_ROD, random, 0.1f, nozzlePoint,
                exhaustDirection.scale(0.1d).add(inheritedMotion));
    }

    protected static void spawnSingleParticle(Level level, ParticleOptions type, RandomSource random, float spread,
                                              Vec3 pos, Vec3 velocity) {
        double jX = (random.nextFloat() * 2.0f - 1.0f) * spread;
        double jY = (random.nextFloat() * 2.0f - 1.0f) * spread;
        double jZ = (random.nextFloat() * 2.0f - 1.0f) * spread;

        double rVX = velocity.x + (random.nextFloat() * 2.0f - 1.0f) * 0.025f;
        double rVY = velocity.y + (random.nextFloat() * 2.0f - 1.0f) * 0.025f;
        double rVZ = velocity.z + (random.nextFloat() * 2.0f - 1.0f) * 0.025f;

        level.addParticle(type, pos.x + jX, pos.y + jY, pos.z + jZ, rVX, rVY, rVZ);
    }

    // Generated by VoxelShape Generators v0.2.0 BlockBench Plugin
    protected static VoxelShape makeBaseShape() {
        VoxelShape shape = Shapes.empty();
        shape = Shapes.join(shape, Shapes.box(0, 0.3125, 0, 1, 1, 0.25), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.0625, 0.5625, 0.625, 0.9375, 1, 1), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.1875, 0.5, 0.15625, 0.8125, 0.8125, 0.15625), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.125, 0.4375, 0, 0.875, 0.4375, 0.1875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.125, 0.875, 0, 0.875, 0.875, 0.1875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.125, 0.4375, 0, 0.125, 0.875, 0.1875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.875, 0.4375, 0, 0.875, 0.875, 0.1875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0, 0.6875, 0.5625, 0.0625, 0.9375, 0.8125), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.0625, 0.5, 0.25, 0.9375, 1, 0.625), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.1875, 0.65625, -0.8125, 0.8125, 0.65625, 0.1875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.1875, 0.65625, -0.8125, 0.8125, 0.65625, 0.1875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.9375, 0.8125, 0.3125, 1, 0.9375, 0.8125), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.9375, 0.625, 0.375, 1, 0.75, 0.875), BooleanOp.OR);
        shape = Shapes.join(shape, Shapes.box(0.5, 0.5, 0.75, 1, 0.625, 0.875), BooleanOp.OR);

        return shape;
    }

    protected static VoxelShape rotationShape(Direction direction, VoxelShape shape) {
        VoxelShape[] buffer = {shape, Shapes.empty()};

        int rotations = (direction.get2DDataValue() - Direction.NORTH.get2DDataValue() + 4) % 4;
        for (int i = 0; i < rotations; i++) {
            buffer[0].forAllBoxes((minX, minY, minZ, maxX, maxY, maxZ) ->
                buffer[1] = Shapes.or(buffer[1], Shapes.box(1 - maxZ, minY, minX, 1 - minZ, maxY, maxX))
            );
            buffer[0] = buffer[1];
            buffer[1] = Shapes.empty();
        }
        return buffer[0];
    }

    public static void playSound(Level level, Vec3 position, RandomSource random) {
        if (random.nextInt(40) == 0) {
            level.playLocalSound(position.x, position.y, position.z, SoundEvents.BEACON_AMBIENT, SoundSource.BLOCKS,
                2.5f + random.nextFloat() * 0.5f, 1.2f + random.nextFloat() * 0.7f, false);
        }

        if (random.nextFloat() < 5e-2f) {
            level.playLocalSound(position.x, position.y, position.z, SoundEvents.LAVA_POP, SoundSource.BLOCKS,
                0.2f + random.nextFloat() * 0.2f, 0.7f + random.nextFloat() * 0.35f, false);
        }
    }

    public static void playSound(Level level, Vec3 position) {
        playSound(level, position, level.random);
    }

    @Override
    public VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {
        return SHAPES.get(state.getValue(FACING));
    }

    @Override
    public BlockState getStateForPlacement(BlockPlaceContext context) {
        return this.defaultBlockState().setValue(FACING, context.getHorizontalDirection().getOpposite());
    }

    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        builder.add(FACING);
    }

    // Animation when block is block; contraption animation is handled in ThrusterMovementBehaviour
    @Override
    public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
        Direction direction = state.getValue(FACING);

        Vec3 center = new Vec3(pos.getX() + 0.5d, pos.getY() + 0.65d, pos.getZ() + 0.5d);
        Vec3 velocity = new Vec3(direction.getStepX(), direction.getStepY(), direction.getStepZ());

        spawnThrusterParticles(level, center, velocity, Vec3.ZERO, random);

        playSound(level, center, random);
    }
}
